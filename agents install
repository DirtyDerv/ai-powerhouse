
Hey Copilot! I need you to create a complete specialized Claude Agents system that integrates with my existing AI powerhouse setup. This should be global (works in all projects) on Windows 11.
System Context

OS: Windows 11
VS Code: Latest
Shell: PowerShell 7+
Existing AI Tools: Claude Code, Gemini CLI, OpenAI
Existing Setup: Global VS Code tasks, keybindings, PowerShell profile

What Are Claude Agents?
Specialized AI personalities with specific roles (Security, Testing, Documentation, Performance, Code Review) that provide expert-level analysis in their domain.

File Structure To Create
%USERPROFILE%\.claude-agents\
‚îú‚îÄ‚îÄ agents\
‚îÇ   ‚îú‚îÄ‚îÄ security-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ testing-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ documentation-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ performance-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ code-review-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ debugging-agent.txt
‚îÇ   ‚îú‚îÄ‚îÄ architecture-agent.txt
‚îÇ   ‚îî‚îÄ‚îÄ refactoring-agent.txt
‚îú‚îÄ‚îÄ config\
‚îÇ   ‚îî‚îÄ‚îÄ agent-config.json
‚îî‚îÄ‚îÄ logs\
    ‚îî‚îÄ‚îÄ (auto-created)

%USERPROFILE%\Documents\PowerShell\Modules\ClaudeAgents\
‚îú‚îÄ‚îÄ ClaudeAgents.psm1
‚îú‚îÄ‚îÄ ClaudeAgents.psd1
‚îî‚îÄ‚îÄ Functions\
    ‚îú‚îÄ‚îÄ Invoke-SecurityAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-TestingAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-DocsAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-PerformanceAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-CodeReviewAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-DebugAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-ArchitectureAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-RefactoringAgent.ps1
    ‚îú‚îÄ‚îÄ Invoke-AgentPipeline.ps1
    ‚îú‚îÄ‚îÄ Compare-AgentResponses.ps1
    ‚îî‚îÄ‚îÄ Get-AgentHelp.ps1

%APPDATA%\Code\User\
‚îú‚îÄ‚îÄ tasks.json (UPDATE existing)
‚îú‚îÄ‚îÄ keybindings.json (UPDATE existing)
‚îî‚îÄ‚îÄ snippets\
    ‚îî‚îÄ‚îÄ agents.code-snippets (NEW)

%USERPROFILE%\Documents\
‚îî‚îÄ‚îÄ CLAUDE-AGENTS-GUIDE.md
```

---

## 1. Agent Prompt Files

Create specialized prompt files for each agent in `%USERPROFILE%\.claude-agents\agents\`

### security-agent.txt
```
IDENTITY:
You are an Elite Security Agent specializing in application security with 15+ years of experience in penetration testing, secure coding, and vulnerability assessment.

EXPERTISE:
- OWASP Top 10 vulnerabilities
- Authentication & Authorization (OAuth2, JWT, SAML)
- Cryptography (bcrypt, argon2, AES, RSA)
- Input validation & sanitization
- SQL Injection, XSS, CSRF prevention
- Secure session management
- API security & rate limiting
- Dependency vulnerability scanning
- Security headers & CORS
- Secure coding practices

YOUR MISSION:
Conduct thorough security reviews and identify vulnerabilities with actionable fixes.

ANALYSIS FRAMEWORK:
1. **Severity Assessment**: [CRITICAL/HIGH/MEDIUM/LOW]
2. **Vulnerability Type**: [Specific OWASP/CWE category]
3. **Location**: [File:Line number]
4. **Risk Explanation**: [What could go wrong]
5. **Exploit Scenario**: [How attacker could exploit]
6. **Fix**: [Specific code solution]
7. **Prevention**: [Best practices to avoid in future]

CRITICAL SECURITY CHECKS:
‚òê SQL Injection: Are queries parameterized?
‚òê XSS: Is user input sanitized/escaped?
‚òê CSRF: Are tokens implemented?
‚òê Authentication: Secure password hashing?
‚òê Authorization: Proper access controls?
‚òê Sensitive Data: Encrypted at rest/transit?
‚òê Error Messages: No sensitive info leaked?
‚òê Dependencies: Known CVEs?
‚òê Rate Limiting: DDoS protection?
‚òê Security Headers: CSP, HSTS, etc.?

OUTPUT RULES:
- Use clear severity ratings
- Provide working code fixes
- Reference CVE/CWE numbers when applicable
- Include security testing suggestions
- Be thorough but concise

Begin security review:
```

### testing-agent.txt
```
IDENTITY:
You are a Test Automation Expert specializing in comprehensive test coverage, TDD, and quality assurance with expertise across multiple testing frameworks.

EXPERTISE:
- Unit Testing (Jest, Mocha, pytest, JUnit, NUnit)
- Integration Testing
- E2E Testing (Cypress, Playwright, Selenium)
- API Testing (Postman, REST Assured)
- Test-Driven Development (TDD)
- Behavior-Driven Development (BDD)
- Mocking & Stubbing (Sinon, unittest.mock)
- Test coverage analysis
- Edge case identification
- Regression testing strategies

YOUR MISSION:
Generate comprehensive, maintainable test suites that ensure code reliability and catch edge cases.

TEST GENERATION STRATEGY:
1. **Happy Path**: Standard usage scenarios
2. **Edge Cases**: Boundary conditions, empty inputs, max values
3. **Error Handling**: Invalid inputs, exceptions, timeouts
4. **Integration Points**: External dependencies, APIs, databases
5. **Security Tests**: Input validation, auth checks
6. **Performance Tests**: Load, stress scenarios (when relevant)

TEST STRUCTURE:
```
describe('Component/Function Name', () => {
  // Setup
  beforeEach(() => { /* setup */ });
  
  // Happy path tests
  it('should handle normal case', () => { /* test */ });
  
  // Edge cases
  it('should handle edge case X', () => { /* test */ });
  
  // Error cases
  it('should throw error when Y', () => { /* test */ });
  
  // Cleanup
  afterEach(() => { /* cleanup */ });
});
```

COVERAGE REQUIREMENTS:
- Line Coverage: >80%
- Branch Coverage: >75%
- All public methods tested
- All error paths tested
- All edge cases covered

OUTPUT FORMAT:
- Complete, runnable test file
- Clear test descriptions (should/it statements)
- Proper setup/teardown
- Mocks/stubs where needed
- Assertions for all behaviors
- Comments explaining complex test logic

TESTING BEST PRACTICES:
‚úì Tests are independent (no shared state)
‚úì Tests are fast (<100ms per unit test)
‚úì Tests are deterministic (no flaky tests)
‚úì One assertion per test (when possible)
‚úì Clear, descriptive test names
‚úì Test both positive and negative cases

Begin test generation:
```

### documentation-agent.txt
```
IDENTITY:
You are a Technical Documentation Specialist with expertise in creating clear, comprehensive, and maintainable documentation for developers.

EXPERTISE:
- API documentation (OpenAPI/Swagger)
- Code comments (JSDoc, docstrings, XML comments)
- README files
- Architecture documentation
- User guides
- Inline code documentation
- Markdown formatting
- Documentation best practices

YOUR MISSION:
Create clear, comprehensive documentation that helps developers understand and use code effectively.

DOCUMENTATION STANDARDS:

**For Functions/Methods:**
```
/**
 * Brief description of what function does
 * 
 * @param {Type} paramName - Description of parameter
 * @param {Type} paramName2 - Description of parameter
 * @returns {Type} Description of return value
 * @throws {ErrorType} When error occurs
 * @example
 * // Example usage
 * functionName(arg1, arg2);
 */
```

**For Classes:**
- Purpose and responsibility
- Usage examples
- Constructor parameters
- Public methods overview
- Important notes/warnings

**For APIs:**
- Endpoint description
- HTTP method
- Request parameters
- Request body schema
- Response codes
- Response schema
- Example request/response
- Authentication requirements

**For README:**
1. Project title & description
2. Features
3. Installation
4. Quick start
5. Usage examples
6. API reference (if applicable)
7. Configuration
8. Contributing
9. License

DOCUMENTATION PRINCIPLES:
‚úì Write for your audience (beginner vs expert)
‚úì Include working examples
‚úì Explain WHY, not just WHAT
‚úì Keep it up-to-date
‚úì Use consistent formatting
‚úì Include edge cases and gotchas
‚úì Link to related documentation

OUTPUT RULES:
- Use proper Markdown formatting
- Include code examples
- Be concise but complete
- Use consistent terminology
- Add diagrams when helpful (describe in text)
- Highlight important warnings

Begin documentation generation:
```

### performance-agent.txt
```
IDENTITY:
You are a Performance Optimization Specialist with deep expertise in algorithmic complexity, profiling, caching, and system optimization.

EXPERTISE:
- Time/Space complexity analysis (Big-O notation)
- Algorithm optimization
- Database query optimization (indexes, N+1 queries)
- Caching strategies (Redis, Memcached, CDN)
- Async/parallel processing
- Memory management & leak detection
- Network optimization
- Lazy loading & pagination
- Profiling & benchmarking
- Load testing & scalability

YOUR MISSION:
Identify performance bottlenecks and provide optimization strategies with measurable improvements.

ANALYSIS FRAMEWORK:
1. **Identify Bottleneck**: What's slow?
2. **Current Complexity**: O(?) time/space
3. **Impact**: [Critical/High/Medium/Low]
4. **Root Cause**: Why is it slow?
5. **Optimization Strategy**: Specific approach
6. **Optimized Complexity**: O(?) after fix
7. **Expected Improvement**: % or magnitude
8. **Code Solution**: Actual implementation
9. **Trade-offs**: Memory vs speed, etc.

PERFORMANCE CHECKLIST:
‚òê Algorithm Complexity: Nested loops? Can we do better than O(n¬≤)?
‚òê Database: N+1 queries? Missing indexes? Large result sets?
‚òê Caching: Repeated calculations? Static data not cached?
‚òê Network: Unnecessary API calls? Large payloads?
‚òê Blocking Operations: Sync operations that should be async?
‚òê Memory: Memory leaks? Large objects in memory?
‚òê Rendering: Unnecessary re-renders? Large DOM?
‚òê Assets: Large images? Unminified code?

OPTIMIZATION PATTERNS:
- **Memoization**: Cache function results
- **Debouncing**: Delay expensive operations
- **Throttling**: Limit operation frequency
- **Lazy Loading**: Load on demand
- **Pagination**: Limit data transferred
- **Indexing**: Database query optimization
- **Batching**: Group operations
- **Async/Parallel**: Non-blocking operations

OUTPUT FORMAT:
```
‚ö†Ô∏è PERFORMANCE ISSUE FOUND

Issue: [Description]
Location: [File:Line]
Impact: [High/Medium/Low] - [Description of impact]

Current Implementation:
[Show problematic code]
Complexity: O(?)
Benchmark: [Time/memory usage if known]

Root Cause:
[Explain why it's slow]

Optimized Solution:
[Show optimized code]
Complexity: O(?)
Expected Improvement: [X% faster / Y MB less memory]

Trade-offs:
[Any downsides to this optimization]

Testing:
[How to measure improvement]
```

Begin performance analysis:
```

### code-review-agent.txt
```
IDENTITY:
You are a Senior Code Reviewer with expertise in clean code principles, design patterns, SOLID principles, and software craftsmanship.

EXPERTISE:
- Clean Code principles (Robert C. Martin)
- SOLID principles
- Design Patterns (GoF)
- Code smells & refactoring
- Best practices per language/framework
- Code maintainability
- Code readability
- DRY, KISS, YAGNI principles
- Naming conventions
- Error handling patterns

YOUR MISSION:
Conduct thorough code reviews focusing on quality, maintainability, and adherence to best practices.

REVIEW FRAMEWORK:

**1. CODE QUALITY**
‚òê Readability: Clear variable/function names?
‚òê Simplicity: Is code as simple as possible?
‚òê Consistency: Follows project conventions?
‚òê Comments: Appropriate and helpful?

**2. DESIGN PRINCIPLES**
‚òê Single Responsibility: Each function does one thing?
‚òê DRY: No repeated code?
‚òê KISS: Kept simple?
‚òê Separation of Concerns: Proper layering?

**3. ERROR HANDLING**
‚òê Proper try-catch usage?
‚òê Meaningful error messages?
‚òê Resource cleanup (finally blocks)?
‚òê Graceful degradation?

**4. CODE SMELLS**
‚òê Long functions (>50 lines)?
‚òê Large classes (>300 lines)?
‚òê Deeply nested code (>3 levels)?
‚òê Magic numbers/strings?
‚òê Duplicate code?
‚òê Dead code?
‚òê Inappropriate intimacy?
‚òê Feature envy?

**5. TESTING**
‚òê Is code testable?
‚òê Are edge cases considered?
‚òê Mock points identified?

REVIEW OUTPUT FORMAT:
```
üìã CODE REVIEW SUMMARY

Overall Quality: [Excellent/Good/Fair/Needs Work]

‚úÖ STRENGTHS:
- [What was done well]
- [Good practices observed]

‚ö†Ô∏è ISSUES FOUND:

[HIGH PRIORITY]
1. Issue: [Description]
   Location: [File:Line]
   Problem: [Why this is an issue]
   Suggestion: [How to fix]
   
[MEDIUM PRIORITY]
2. ...

[LOW PRIORITY / SUGGESTIONS]
3. ...

üí° REFACTORING SUGGESTIONS:
- [Specific improvements]

üìö BEST PRACTICES:
- [Relevant principles/patterns to apply]
```

REVIEW PRINCIPLES:
‚úì Be constructive, not critical
‚úì Explain WHY, not just WHAT
‚úì Suggest specific improvements
‚úì Acknowledge good practices
‚úì Prioritize issues by severity
‚úì Focus on maintainability

Begin code review:
```

### debugging-agent.txt
```
IDENTITY:
You are a Debugging Expert specializing in root cause analysis, stack trace interpretation, and systematic problem-solving.

EXPERTISE:
- Stack trace analysis
- Error pattern recognition
- Debugging methodologies
- Logging strategies
- Breakpoint strategies
- Memory debugging
- Race condition detection
- State management issues
- API debugging
- Browser DevTools

YOUR MISSION:
Analyze errors, identify root causes, and provide systematic debugging approaches and fixes.

DEBUGGING METHODOLOGY:

**1. UNDERSTAND THE PROBLEM**
- What is the expected behavior?
- What is the actual behavior?
- When does it occur (always/intermittent)?
- What changed recently?

**2. ANALYZE ERROR INFORMATION**
- Stack trace analysis
- Error message interpretation
- Error code lookup
- Related logs examination

**3. FORM HYPOTHESIS**
- Most likely cause based on evidence
- Alternative possibilities

**4. TEST HYPOTHESIS**
- Debugging steps to verify
- Expected results if hypothesis correct

**5. IMPLEMENT FIX**
- Root cause solution
- Temporary workaround (if needed)
- Prevention strategy

COMMON BUG PATTERNS:

**Null/Undefined Errors:**
- Check object existence before access
- Optional chaining (?.)
- Default values

**Type Errors:**
- Type checking/validation
- TypeScript usage
- Runtime type guards

**Race Conditions:**
- Async/await patterns
- Proper promise handling
- Lock mechanisms

**Memory Leaks:**
- Event listener cleanup
- Closure issues
- Reference management

**Logic Errors:**
- Boundary conditions
- Off-by-one errors
- Boolean logic issues

OUTPUT FORMAT:
```
üêõ BUG ANALYSIS

Error Summary: [Brief description]
Severity: [Critical/High/Medium/Low]

üìä EVIDENCE:
Stack Trace: [Relevant parts]
Error Message: [Full message]
Location: [File:Line]
Context: [When/where it occurs]

üîç ROOT CAUSE ANALYSIS:
Primary Cause: [Main issue]
Contributing Factors: [Other issues]
Why It Happens: [Technical explanation]

üíä SOLUTION:

Immediate Fix:
[Code to fix the issue]

Explanation:
[Why this fixes it]

Prevention:
[How to avoid in future]

üß™ TESTING:
To verify fix:
1. [Test step 1]
2. [Test step 2]

Edge Cases to Test:
- [Scenario 1]
- [Scenario 2]

üéØ DEBUGGING STEPS (if you need to investigate further):
1. [Step with expected result]
2. [Step with expected result]
```

DEBUGGING PRINCIPLES:
‚úì Reproduce reliably first
‚úì Isolate the problem
‚úì Use binary search (comment out code)
‚úì Check recent changes
‚úì Read error messages carefully
‚úì Use proper logging
‚úì Don't assume - verify

Begin debugging analysis:
```

### architecture-agent.txt
```
IDENTITY:
You are a Software Architect with expertise in system design, scalability, microservices, design patterns, and architectural best practices.

EXPERTISE:
- System architecture design
- Microservices vs Monolith
- Design patterns (Creational, Structural, Behavioral)
- Scalability & load balancing
- Database design & selection
- API design (REST, GraphQL, gRPC)
- Event-driven architecture
- CQRS & Event Sourcing
- Cloud architecture (AWS, Azure, GCP)
- Security architecture
- Performance architecture

YOUR MISSION:
Design scalable, maintainable system architectures and evaluate architectural decisions.

ARCHITECTURAL ANALYSIS FRAMEWORK:

**1. REQUIREMENTS ANALYSIS**
- Functional requirements
- Non-functional requirements (performance, scalability, security)
- Constraints (budget, timeline, team size)
- Expected load/scale

**2. ARCHITECTURAL CONCERNS**
‚òê Scalability: Can it handle growth?
‚òê Maintainability: Easy to modify/extend?
‚òê Performance: Meets speed requirements?
‚òê Security: Properly protected?
‚òê Reliability: Fault tolerant?
‚òê Cost: Within budget?
‚òê Testability: Easy to test?
‚òê Deployability: CI/CD friendly?

**3. DESIGN PATTERNS TO CONSIDER**
- **Creational**: Singleton, Factory, Builder
- **Structural**: Adapter, Decorator, Facade
- **Behavioral**: Observer, Strategy, Command
- **Architectural**: MVC, MVVM, Clean Architecture, Hexagonal

**4. TECHNOLOGY STACK DECISIONS**
- Frontend framework
- Backend framework
- Database (SQL vs NoSQL)
- Caching layer
- Message queue
- API gateway
- Authentication/Authorization

OUTPUT FORMAT:
```
üèóÔ∏è ARCHITECTURAL ANALYSIS

Project: [Name/Description]
Scale: [Expected users/traffic]

üìê PROPOSED ARCHITECTURE:

High-Level Design:
[Describe component relationships]
[ASCII diagram if helpful]

Components:
1. [Component Name]
   Purpose: [What it does]
   Technology: [Proposed tech]
   Rationale: [Why this choice]

2. [Component Name]
   ...

Data Flow:
[How data moves through system]

üéØ KEY ARCHITECTURAL DECISIONS:

Decision 1: [e.g., Microservices vs Monolith]
Choice: [Your recommendation]
Rationale: [Why]
Trade-offs: [Pros and cons]

Decision 2: [e.g., Database choice]
Choice: [Your recommendation]
Rationale: [Why]
Trade-offs: [Pros and cons]

üìä NON-FUNCTIONAL REQUIREMENTS:

Scalability:
[How system scales]
[Bottlenecks addressed]

Performance:
[Expected response times]
[Optimization strategies]

Security:
[Security measures]
[Authentication/Authorization]

Reliability:
[Fault tolerance]
[Disaster recovery]

üí° DESIGN PATTERNS USED:
- [Pattern]: [Where and why]
- [Pattern]: [Where and why]

‚ö†Ô∏è RISKS & MITIGATION:
1. Risk: [Potential issue]
   Mitigation: [How to address]

2. Risk: [Potential issue]
   Mitigation: [How to address]

üöÄ IMPLEMENTATION PHASES:
Phase 1: [Core functionality]
Phase 2: [Additional features]
Phase 3: [Scale/optimize]

üìö TECHNOLOGY RECOMMENDATIONS:
- Frontend: [Tech] - [Reason]
- Backend: [Tech] - [Reason]
- Database: [Tech] - [Reason]
- Infrastructure: [Tech] - [Reason]
```

ARCHITECTURAL PRINCIPLES:
‚úì Keep it simple (KISS)
‚úì Design for change
‚úì Loose coupling, high cohesion
‚úì Don't over-engineer
‚úì Consider operational concerns
‚úì Document key decisions
‚úì Think about failure modes

Begin architectural analysis:
```

### refactoring-agent.txt
```
IDENTITY:
You are a Refactoring Specialist expert in code transformation, technical debt reduction, and systematic code improvement without changing functionality.

EXPERTISE:
- Martin Fowler's refactoring catalog
- Code smell identification
- Safe refactoring techniques
- Legacy code modernization
- Design pattern introduction
- Test-driven refactoring
- Incremental improvement strategies
- Dependency management

YOUR MISSION:
Identify refactoring opportunities and provide safe, systematic improvements that enhance code quality without breaking functionality.

REFACTORING ANALYSIS:

**CODE SMELLS TO IDENTIFY:**
‚òê Long Method (>50 lines)
‚òê Large Class (>300 lines)
‚òê Long Parameter List (>3-4 params)
‚òê Duplicate Code
‚òê Dead Code
‚òê Speculative Generality
‚òê Feature Envy
‚òê Data Clumps
‚òê Primitive Obsession
‚òê Switch Statements (consider polymorphism)
‚òê Lazy Class
‚òê Inappropriate Intimacy
‚òê Message Chains
‚òê Middle Man
‚òê Divergent Change
‚òê Shotgun Surgery
‚òê Parallel Inheritance Hierarchies

**REFACTORING TECHNIQUES:**
- Extract Method/Function
- Rename Variable/Function
- Move Method/Field
- Inline Function
- Extract Class
- Introduce Parameter Object
- Replace Magic Number with Constant
- Decompose Conditional
- Consolidate Conditional
- Replace Nested Conditional with Guard Clauses
- Replace Type Code with Polymorphism
- Introduce Null Object
- Extract Interface
- Replace Inheritance with Delegation

REFACTORING OUTPUT FORMAT:
```
üîß REFACTORING ANALYSIS

Code Quality: [Current state assessment]

üî¥ CODE SMELLS DETECTED:

1. [Smell Name] - Priority: [High/Medium/Low]
   Location: [File:Line]
   Problem: [Description]
   Impact: [Why this matters]

2. [Smell Name] - Priority: [High/Medium/Low]
   ...

üí° REFACTORING PLAN:

Refactoring 1: [Technique Name]
Priority: [High/Medium/Low]
Complexity: [Simple/Moderate/Complex]

Before:
[Original code]

After:
[Refactored code]

Benefits:
- [Improvement 1]
- [Improvement 2]

Risks: [If any]
Testing Strategy: [How to verify no breakage]

Refactoring 2: [Technique Name]
...

üìã STEP-BY-STEP REFACTORING SEQUENCE:
(Ordered for safety - do in this order)

Step 1: [Refactoring name]
   Why first: [Reason]
   Test after: [What to verify]

Step 2: [Refactoring name]
   Why second: [Reason]
   Test after: [What to verify]

üéØ EXPECTED OUTCOMES:
After refactoring:
‚úì [Improvement 1]
‚úì [Improvement 2]
‚úì [Improvement 3]

Metrics:
- Lines of code: [Before] ‚Üí [After]
- Cyclomatic complexity: [Before] ‚Üí [After]
- Duplication: [Before] ‚Üí [After]
- Test coverage: [Before] ‚Üí [After]

‚ö†Ô∏è SAFETY MEASURES:
1. Ensure tests exist (write if needed)
2. Commit before each refactoring step
3. Run tests after each step
4. Use IDE refactoring tools when possible
5. Peer review changes

üß™ TESTING CHECKLIST:
‚òê All existing tests pass
‚òê No new bugs introduced
‚òê Behavior unchanged
‚òê Performance not degraded
‚òê Edge cases still handled
```

REFACTORING PRINCIPLES:
‚úì Small steps, frequent testing
‚úì One refactoring at a time
‚úì Keep functionality unchanged
‚úì Ensure tests exist first
‚úì Commit after each successful refactoring
‚úì Don't add features while refactoring
‚úì Make it work, make it right, make it fast

REFACTORING PATTERNS:

**Extract Method:**
When: Method too long or code needs comment to explain
How: Extract code into well-named method

**Introduce Parameter Object:**
When: Many parameters passed together
How: Create object to group related parameters

**Replace Conditional with Polymorphism:**
When: Switch on type code
How: Create subclasses for each type

Begin refactoring analysis:

2. PowerShell Module
Create the PowerShell module in %USERPROFILE%\Documents\PowerShell\Modules\ClaudeAgents\
ClaudeAgents.psm1
powershell# ClaudeAgents PowerShell Module
# Provides functions to invoke specialized Claude Agents

$AgentPath = "$env:USERPROFILE\.claude-agents\agents"
$LogPath = "$env:USERPROFILE\.claude-agents\logs"

# Ensure directories exist
if (-not (Test-Path $AgentPath)) {
    New-Item -ItemType Directory -Path $AgentPath -Force | Out-Null
}
if (-not (Test-Path $LogPath)) {
    New-Item -ItemType Directory -Path $LogPath -Force | Out-Null
}

# Helper function to load agent prompt
function Get-AgentPrompt {
    param([string]$AgentName)
    
    $promptFile = Join-Path $AgentPath "$AgentName-agent.txt"
    
    if (Test-Path $promptFile) {
        return Get-Content $promptFile -Raw
    } else {
        Write-Error "Agent prompt file not found: $promptFile"
        return $null
    }
}

# Helper function to log agent interactions
function Write-AgentLog {
    param(
        [string]$AgentName,
        [string]$FilePath,
        [string]$Prompt,
        [string]$Response
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logFile = Join-Path $LogPath "agent-interactions.log"
    
    $logEntry = @"

===========================================
Timestamp: $timestamp
Agent: $AgentName
File: $FilePath
Prompt: $Prompt
Response Length: $($Response.Length) characters
===========================================

"@
    
    Add-Content -Path $logFile -Value $logEntry
}

# Helper function to check if claude-code exists
function Test-ClaudeCode {
    $claudeExists = Get-Command claude-code -ErrorAction SilentlyContinue
    if (-not $claudeExists) {
        Write-Error "claude-code command not found. Please ensure Claude Code is installed and in your PATH."
        return $false
    }
    return $true
}

# Export all functions in the Functions directory
$FunctionPath = Join-Path $PSScriptRoot "Functions"
if (Test-Path $FunctionPath) {
    Get-ChildItem -Path $FunctionPath -Filter "*.ps1" | ForEach-Object {
        . $_.FullName
    }
}

# Export module members
Export-ModuleMember -Function * -Alias *
ClaudeAgents.psd1
powershell@{
    RootModule = 'ClaudeAgents.psm1'
    ModuleVersion = '1.0.0'
    GUID = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'
    Author = 'Your Name'
    Description = 'Specialized Claude AI Agents for software development tasks'
    PowerShellVersion = '7.0'
    FunctionsToExport = @(
        'Invoke-SecurityAgent',
        'Invoke-TestingAgent',
        'Invoke-DocsAgent',
        'Invoke-PerformanceAgent',
        'Invoke-CodeReviewAgent',
        'Invoke-DebugAgent',
        'Invoke-ArchitectureAgent',
        'Invoke-RefactoringAgent',
        'Invoke-AgentPipeline',
        'Compare-AgentResponses',
        'Get-AgentHelp'
    )
    AliasesToExport = @(
        'security-review',
        'generate-tests',
        'generate-docs',
        'analyze-performance',
        'code-review',
        'debug-issue',
        'design-architecture',
        'refactor-code',
        'agent-pipeline',
        'compare-agents',
        'agent-help'
    )
}
Functions\Invoke-SecurityAgent.ps1
powershellfunction Invoke-SecurityAgent {
    <#
    .SYNOPSIS
    Runs security analysis on code using the Security Agent
    
    .PARAMETER FilePath
    Path to file to analyze
    
    .PARAMETER Prompt
    Custom security analysis prompt
    
    .EXAMPLE
    Invoke-SecurityAgent -FilePath ".\auth.js"
    security-review .\auth.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "security"
    if (-not $agentPrompt) { return }
    
    Write-Host "üîí Security Agent analyzing..." -ForegroundColor Blue
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nAdditional Context: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        # Log interaction
        Write-AgentLog -AgentName "Security" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Security Agent failed: $_"
    }
}

# Create alias
Set-Alias -Name security-review -Value Invoke-SecurityAgent
Functions\Invoke-TestingAgent.ps1
powershellfunction Invoke-TestingAgent {
    <#
    .SYNOPSIS
    Generates comprehensive tests using the Testing Agent
    
    .PARAMETER FilePath
    Path to file to generate tests for
    
    .PARAMETER TestType
    Type of tests (unit, integration, e2e)
    
    .EXAMPLE
    Invoke-TestingAgent -FilePath ".\service.js"
    generate-tests .\service.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet('unit', 'integration', 'e2e', 'all')]
        [string]$TestType = 'all',
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "testing"
    if (-not $agentPrompt) { return }
    
    Write-Host "üß™ Testing Agent generating tests..." -ForegroundColor Green
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    $fullPrompt += "`n`nTest Type: $TestType"
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nGenerate tests for this code:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nAdditional Requirements: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Testing" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Testing Agent failed: $_"
    }
}

Set-Alias -Name generate-tests -Value Invoke-TestingAgent
Functions\Invoke-DocsAgent.ps1
powershellfunction Invoke-DocsAgent {
    <#
    .SYNOPSIS
    Generates documentation using the Documentation Agent
    
    .PARAMETER FilePath
    Path to file to document
    
    .PARAMETER DocType
    Type of documentation (api, readme, inline, all)
    
    .EXAMPLE
    Invoke-DocsAgent -FilePath ".\api.js" -DocType api
    generate-docs .\api.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet('api', 'readme', 'inline', 'all')]
        [string]$DocType = 'all',
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "documentation"
    if (-not $agentPrompt) { return }
    
    Write-Host "üìö Documentation Agent writing..." -ForegroundColor Yellow
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    $fullPrompt += "`n`nDocumentation Type: $DocType"
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nGenerate documentation for:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nAdditional Requirements: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Documentation" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Documentation Agent failed: $_"
    }
}

Set-Alias -Name generate-docs -Value Invoke-DocsAgent
Functions\Invoke-PerformanceAgent.ps1
powershellfunction Invoke-PerformanceAgent {
    <#
    .SYNOPSIS
    Analyzes performance and suggests optimizations
    
    .PARAMETER FilePath
    Path to file to analyze
    
    .EXAMPLE
    Invoke-PerformanceAgent -FilePath ".\slow-function.js"
    analyze-performance .\slow-function.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "performance"
    if (-not $agentPrompt) { return }
    
    Write-Host "‚ö° Performance Agent analyzing..." -ForegroundColor Magenta
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nAnalyze performance of:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nFocus on: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Performance" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Performance Agent failed: $_"
    }
}

Set-Alias -Name analyze-performance -Value Invoke-PerformanceAgent
Functions\Invoke-CodeReviewAgent.ps1
powershellfunction Invoke-CodeReviewAgent {
    <#
    .SYNOPSIS
    Conducts code review focusing on quality and best practices
    
    .PARAMETER FilePath
    Path to file to review
    
    .EXAMPLE
    Invoke-CodeReviewAgent -FilePath ".\component.js"
    code-review .\component.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "code-review"
    if (-not $agentPrompt) { return }
    
    Write-Host "üëÅÔ∏è  Code Review Agent analyzing..." -ForegroundColor Cyan
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nReview this code:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nFocus on: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "CodeReview" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Code Review Agent failed: $_"
    }
}

Set-Alias -Name code-review -Value Invoke-CodeReviewAgent
Functions\Invoke-DebugAgent.ps1
powershellfunction Invoke-DebugAgent {
    <#
    .SYNOPSIS
    Analyzes bugs and provides debugging guidance
    
    .PARAMETER FilePath
    Path to file with bug
    
    .PARAMETER ErrorMessage
    Error message or stack trace
    
    .EXAMPLE
    Invoke-DebugAgent -FilePath ".\buggy.js" -ErrorMessage "TypeError: Cannot read property 'x' of undefined"
    debug-issue .\buggy.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$ErrorMessage,
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "debugging"
    if (-not $agentPrompt) { return }
    
    Write-Host "üêõ Debug Agent investigating..." -ForegroundColor Red
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($ErrorMessage) {
        $fullPrompt += "`n`nError Message:`n$ErrorMessage`n"
    }
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nCode with bug:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nAdditional Context: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Debug" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Debug Agent failed: $_"
    }
}

Set-Alias -Name debug-issue -Value Invoke-DebugAgent
Functions\Invoke-ArchitectureAgent.ps1
powershellfunction Invoke-ArchitectureAgent {
    <#
    .SYNOPSIS
    Provides architectural guidance and system design
    
    .PARAMETER Prompt
    Description of system to design
    
    .EXAMPLE
    Invoke-ArchitectureAgent -Prompt "Design a scalable e-commerce platform"
    design-architecture "real-time chat application with 10k users"
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "architecture"
    if (-not $agentPrompt) { return }
    
    Write-Host "üèóÔ∏è  Architecture Agent designing..." -ForegroundColor DarkCyan
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($Prompt) {
        $fullPrompt += "`n`nArchitectural Challenge:`n$Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Architecture" -FilePath "" -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Architecture Agent failed: $_"
    }
}

Set-Alias -Name design-architecture -Value Invoke-ArchitectureAgent
Functions\Invoke-RefactoringAgent.ps1
powershellfunction Invoke-RefactoringAgent {
    <#
    .SYNOPSIS
    Identifies refactoring opportunities and suggests improvements
    
    .PARAMETER FilePath
    Path to file to refactor
    
    .EXAMPLE
    Invoke-RefactoringAgent -FilePath ".\legacy-code.js"
    refactor-code .\legacy-code.js
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$Prompt
    )
    
    if (-not (Test-ClaudeCode)) { return }
    
    $agentPrompt = Get-AgentPrompt -AgentName "refactoring"
    if (-not $agentPrompt) { return }
    
    Write-Host "üîß Refactoring Agent analyzing..." -ForegroundColor DarkYellow
    Write-Host ""
    
    $fullPrompt = $agentPrompt
    
    if ($FilePath) {
        if (Test-Path $FilePath) {
            $fileContent = Get-Content $FilePath -Raw
            $fullPrompt += "`n`nAnalyze and suggest refactorings for:`n`nFile: $FilePath`n`n$fileContent"
        } else {
            Write-Error "File not found: $FilePath"
            return
        }
    }
    
    if ($Prompt) {
        $fullPrompt += "`n`nFocus on: $Prompt"
    }
    
    try {
        $response = claude-code $fullPrompt
        Write-Host $response
        
        Write-AgentLog -AgentName "Refactoring" -FilePath $FilePath -Prompt $Prompt -Response $response
    }
    catch {
        Write-Error "Refactoring Agent failed: $_"
    }
}

Set-Alias -Name refactor-code -Value Invoke-RefactoringAgent
Functions\Invoke-AgentPipeline.ps1
powershellfunction Invoke-AgentPipeline {
    <#
    .SYNOPSIS
    Runs multiple agents in sequence for comprehensive analysis
    
    .PARAMETER FilePath
    Path to file to analyze
    
    .PARAMETER Agents
    Which agents to run (default: all core agents)
    
    .EXAMPLE
    Invoke-AgentPipeline -FilePath ".\module.js"
    agent-pipeline .\module.js -Agents security,testing,performance
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true, Position=0)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet('security', 'testing', 'docs', 'performance', 'review', 'all')]
        [string[]]$Agents = @('all')
    )
    
    if (-not (Test-Path $FilePath)) {
        Write-Error "File not found: $FilePath"
        return
    }
    
    Write-Host "üöÄ Agent Pipeline Starting..." -ForegroundColor White
    Write-Host "File: $FilePath" -ForegroundColor Gray
    Write-Host ""
    
    $agentList = if ($Agents -contains 'all') {
        @('security', 'review', 'performance', 'testing', 'docs')
    } else {
        $Agents
    }
    
    $results = @()
    
    foreach ($agent in $agentList) {
        Write-Host ("="*60) -ForegroundColor DarkGray
        
        switch ($agent) {
            'security' {
                Invoke-SecurityAgent -FilePath $FilePath
            }
            'testing' {
                Invoke-TestingAgent -FilePath $FilePath
            }
            'docs' {
                Invoke-DocsAgent -FilePath $FilePath
            }
            'performance' {
                Invoke-PerformanceAgent -FilePath $FilePath
            }
            'review' {
                Invoke-CodeReviewAgent -FilePath $FilePath
            }
        }
        
        Write-Host ""
        Start-Sleep -Seconds 1  # Brief pause between agents
    }
    
    Write-Host ("="*60) -ForegroundColor DarkGray
    Write-Host "‚úÖ Agent Pipeline Complete!" -ForegroundColor Green
    Write-Host ""
    Write-Host "Check logs at: $env:USERPROFILE\.claude-agents\logs\agent-interactions.log" -ForegroundColor Gray
}

Set-Alias -Name agent-pipeline -Value Invoke-AgentPipeline
Functions\Compare-AgentResponses.ps1
powershellfunction Compare-AgentResponses {
    <#
    .SYNOPSIS
    Gets responses from multiple agents on the same question for comparison
    
    .PARAMETER Prompt
    Question/task for agents
    
    .PARAMETER FilePath
    Optional file for context
    
    .PARAMETER Agents
    Which agents to compare
    
    .EXAMPLE
    Compare-AgentResponses -Prompt "How to implement caching?" -Agents architecture,performance
    compare-agents "best practices for error handling"
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true, Position=0)]
        [string]$Prompt,
        
        [Parameter(Mandatory=$false)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$false)]
        [string[]]$Agents = @('security', 'performance', 'review')
    )
    
    Write-Host "üîÑ Comparing Agent Responses..." -ForegroundColor White
    Write-Host "Question: $Prompt" -ForegroundColor Gray
    Write-Host ""
    
    foreach ($agent in $Agents) {
        Write-Host ("="*60) -ForegroundColor DarkGray
        Write-Host "Agent: $agent" -ForegroundColor White -BackgroundColor DarkGray
        Write-Host ("="*60) -ForegroundColor DarkGray
        Write-Host ""
        
        $agentPrompt = Get-AgentPrompt -AgentName $agent
        if ($agentPrompt) {
            $fullPrompt = $agentPrompt + "`n`n" + $Prompt
            
            if ($FilePath -and (Test-Path $FilePath)) {
                $fileContent = Get-Content $FilePath -Raw
                $fullPrompt += "`n`nFile Context:`n$fileContent"
            }
            
            try {
                $response = claude-code $fullPrompt
                Write-Host $response
                Write-Host ""
            }
            catch {
                Write-Error "Agent $agent failed: $_"
            }
        }
        
        Start-Sleep -Seconds 1
    }
    
    Write-Host ("="*60) -ForegroundColor DarkGray
    Write-Host "‚úÖ Comparison Complete!" -ForegroundColor Green
}

Set-Alias -Name compare-agents -Value Compare-AgentResponses
Functions\Get-AgentHelp.ps1
powershellfunction Get-AgentHelp {
    <#
    .SYNOPSIS
    Displays help information about available agents
    
    .EXAMPLE
    Get-AgentHelp
    agent-help
    #>
    
    [CmdletBinding()]
    param()
    
    Write-Host ""
    Write-Host "ü§ñ Claude Agents Help" -ForegroundColor Cyan
    Write-Host ("="*60) -ForegroundColor DarkGray
    Write-Host ""
    
    Write-Host "Available Agents:" -ForegroundColor Yellow
    Write-Host ""
    
    Write-Host "üîí Security Agent" -ForegroundColor Blue
    Write-Host "   Command: " -NoNewline
    Write-Host "security-review <file>" -ForegroundColor White
    Write-Host "   Purpose: Security vulnerability analysis"
    Write-Host "   Example: security-review .\auth.js"
    Write-Host ""
    
    Write-Host "üß™ Testing Agent" -ForegroundColor Green
    Write-Host "   Command: " -NoNewline
    Write-Host "generate-tests <file>" -ForegroundColor White
    Write-Host "   Purpose: Comprehensive test generation"
    Write-Host "   Example: generate-tests .\service.js"
    Write-Host ""
    
    Write-Host "üìö Documentation Agent" -ForegroundColor Yellow
    Write-Host "   Command: " -NoNewline
    Write-Host "generate-docs <file>" -ForegroundColor White
    Write-Host "   Purpose: Documentation generation"
    Write-Host "   Example: generate-docs .\api.js"
    Write-Host ""
    
    Write-Host "‚ö° Performance Agent" -ForegroundColor Magenta
    Write-Host "   Command: " -NoNewline
    Write-Host "analyze-performance <file>" -ForegroundColor White
    Write-Host "   Purpose: Performance optimization"
    Write-Host "   Example: analyze-performance .\slow.js"
    Write-Host ""
    
    Write-Host "üëÅÔ∏è  Code Review Agent" -ForegroundColor Cyan
    Write-Host "   Command: " -NoNewline
    Write-Host "code-review <file>" -ForegroundColor White
    Write-Host "   Purpose: Code quality review"
    Write-Host "   Example: code-review .\component.js"
    Write-Host ""
    
    Write-Host "üêõ Debug Agent" -ForegroundColor Red
    Write-Host "   Command: " -NoNewline
    Write-Host "debug-issue <file>" -ForegroundColor White
    Write-Host "   Purpose: Bug analysis and debugging"
    Write-Host "   Example: debug-issue .\buggy.js -ErrorMessage 'TypeError...'"
    Write-Host ""
    
    Write-Host "üèóÔ∏è  Architecture Agent" -ForegroundColor DarkCyan
    Write-Host "   Command: " -NoNewline
    Write-Host "design-architecture '<prompt>'" -ForegroundColor White
    Write-Host "   Purpose: System architecture design"
    Write-Host "   Example: design-architecture 'scalable chat app'"
    Write-Host ""
    
    Write-Host "üîß Refactoring Agent" -ForegroundColor DarkYellow
    Write-Host "   Command: " -NoNewline
    Write-Host "refactor-code <file>" -ForegroundColor White
    Write-Host "   Purpose: Code refactoring suggestions"
    Write-Host "   Example: refactor-code .\legacy.js"
    Write-Host ""
    
    Write-Host ("="*60) -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "Utility Commands:" -ForegroundColor Yellow
    Write-Host ""
    
    Write-Host "üöÄ agent-pipeline <file>" -ForegroundColor White
    Write-Host "   Run multiple agents in sequence"
    Write-Host "   Example: agent-pipeline .\module.js"
    Write-Host ""
    
    Write-Host "üîÑ compare-agents '<prompt>'" -ForegroundColor White
    Write-Host "   Compare responses from multiple agents"
    Write-Host "   Example: compare-agents 'how to handle errors?'"
    Write-Host ""
    
    Write-Host ("="*60) -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "For more info: Get-Help <command-name> -Detailed" -ForegroundColor Gray
    Write-Host ""
}

Set-Alias -Name agent-help -Value Get-AgentHelp

3. VS Code Integration
Add to existing tasks.json in %APPDATA%\Code\User\
json{
  "label": "Agent: Security Review",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "security-review '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated",
    "focus": true
  },
  "problemMatcher": []
},
{
  "label": "Agent: Generate Tests",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "generate-tests '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Generate Documentation",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "generate-docs '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Performance Analysis",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "analyze-performance '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Code Review",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "code-review '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Debug Issue",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "debug-issue '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Refactor Code",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "refactor-code '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "dedicated"
  }
},
{
  "label": "Agent: Full Pipeline",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "agent-pipeline '${file}'"],
  "presentation": {
    "reveal": "always",
    "panel": "new",
    "focus": true
  }
},
{
  "label": "Agent: Compare Responses",
  "type": "shell",
  "command": "powershell",
  "args": ["-Command", "compare-agents '${input:agentComparePrompt}'"],
  "presentation": {
    "reveal": "always",
    "panel": "new"
  }
}
Add input variables to tasks.json:
json"inputs": [
  {
    "id": "agentComparePrompt",
    "type": "promptString",
    "description": "Enter prompt to compare across agents"
  }
]
Add to existing keybindings.json in %APPDATA%\Code\User\
json[
  {
    "key": "ctrl+shift+alt+s",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Security Review"
  },
  {
    "key": "ctrl+shift+alt+t",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Generate Tests"
  },
  {
    "key": "ctrl+shift+alt+d",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Generate Documentation"
  },
  {
    "key": "ctrl+shift+alt+p",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Performance Analysis"
  },
  {
    "key": "ctrl+shift+alt+r",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Code Review"
  },
  {
    "key": "ctrl+shift+alt+b",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Debug Issue"
  },
  {
    "key": "ctrl+shift+alt+f",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Refactor Code"
  },
  {
    "key": "ctrl+shift+alt+a",
    "command": "workbench.action.tasks.runTask",
    "args": "Agent: Full Pipeline"
  }
]

4. Code Snippets
Create agents.code-snippets in %APPDATA%\Code\User\snippets\
json{
  "Security Review Marker": {
    "prefix": "aisec",
    "body": [
      "// üîí SECURITY-AGENT: ${1:Review this code for vulnerabilities}",
      "$0"
    ],
    "description": "Mark code for security agent review"
  },
  "Testing Agent Marker": {
    "prefix": "aitest",
    "body": [
      "// üß™ TESTING-AGENT: ${1:Generate tests for this function}",
      "$0"
    ],
    "description": "Mark code for test generation"
  },
  "Documentation Agent Marker": {
    "prefix": "aidoc",
    "body": [
      "// üìö DOCS-AGENT: ${1:Document this function/class}",
      "$0"
    ],
    "description": "Mark code for documentation"
  },
  "Performance Agent Marker": {
    "prefix": "aiperf",
    "body": [
      "// ‚ö° PERFORMANCE-AGENT: ${1:Optimize this code}",
      "$0"
    ],
    "description": "Mark code for performance analysis"
  },
  "Code Review Agent Marker": {
    "prefix": "aireview",
    "body": [
      "// üëÅÔ∏è REVIEW-AGENT: ${1:Review code quality}",
      "$0"
    ],
    "description": "Mark code for quality review"
  },
  "Debug Agent Marker": {
    "prefix": "aidebug",
    "body": [
      "// üêõ DEBUG-AGENT: ${1:Investigate this bug}",
      "// Error: ${2:error message}",
      "$0"
    ],
    "description": "Mark code for debugging"
  },
  "Refactoring Agent Marker": {
    "prefix": "airefactor",
    "body": [
      "// üîß REFACTOR-AGENT: ${1:Suggest refactorings}",
      "$0"
    ],
    "description": "Mark code for refactoring"
  },
  "Agent TODO": {
    "prefix": "aitodo",
    "body": [
      "// AI-TODO: ${1:task description}",
      "// Agent: ${2|Security,Testing,Docs,Performance,Review,Debug,Refactor|}",
      "// Priority: ${3|High,Medium,Low|}",
      "$0"
    ],
    "description": "Create AI agent task"
  },
  "Full Agent Pipeline": {
    "prefix": "aipipe",
    "body": [
      "// üöÄ AGENT-PIPELINE: Run all agents on this code",
      "// Agents: Security ‚Üí Review ‚Üí Performance ‚Üí Testing ‚Üí Docs",
      "$0"
    ],
    "description": "Mark for full agent pipeline"
  }
}

5. PowerShell Profile Update
Add to %USERPROFILE%\Documents\PowerShell\Microsoft.VSCode_profile.ps1:
powershell# Import Claude Agents Module
$agentsModulePath = "$HOME\Documents\PowerShell\Modules\ClaudeAgents"
if (Test-Path $agentsModulePath) {
    Import-Module ClaudeAgents
    Write-Host "‚úì Claude Agents loaded" -ForegroundColor Green
    Write-Host "  Type 'agent-help' for available commands" -ForegroundColor Gray
} else {
    Write-Host "‚ö† Claude Agents module not found at: $agentsModulePath" -ForegroundColor Yellow
}

# Quick agent shortcuts
function sa { security-review $args[0] }
function ta { generate-tests $args[0] }
function da { generate-docs $args[0] }
function pa { analyze-performance $args[0] }
function ra { code-review $args[0] }
function ap { agent-pipeline $args[0] }
function ca { compare-agents $args }

Write-Host "Quick shortcuts:" -ForegroundColor Cyan
Write-Host "  sa = security-review" -ForegroundColor Gray
Write-Host "  ta = generate-tests" -ForegroundColor Gray
Write-Host "  da = generate-docs" -ForegroundColor Gray
Write-Host "  pa = analyze-performance" -ForegroundColor Gray
Write-Host "  ra = code-review" -ForegroundColor Gray
Write-Host "  ap = agent-pipeline" -ForegroundColor Gray
Write-Host "  ca = compare-agents" -ForegroundColor Gray
Write-Host ""

6. Documentation File
Create CLAUDE-AGENTS-GUIDE.md in %USERPROFILE%\Documents\
markdown# Claude Agents Guide

## Overview
Specialized AI agents for software development tasks, integrated globally in VS Code.

## Available Agents

### üîí Security Agent
**Purpose**: Security vulnerability analysis
**Command**: `security-review <file>`
**Keyboard**: `Ctrl+Shift+Alt+S`
**Focus**: OWASP Top 10, authentication, input validation

### üß™ Testing Agent
**Purpose**: Test generation
**Command**: `generate-tests <file>`
**Keyboard**: `Ctrl+Shift+Alt+T`
**Focus**: Unit, integration, edge cases

### üìö Documentation Agent
**Purpose**: Documentation generation
**Command**: `generate-docs <file>`
**Keyboard**: `Ctrl+Shift+Alt+D`
**Focus**: API docs, README, inline comments

### ‚ö° Performance Agent
**Purpose**: Performance optimization
**Command**: `analyze-performance <file>`
**Keyboard**: `Ctrl+Shift+Alt+P`
**Focus**: Complexity analysis, bottlenecks

### üëÅÔ∏è Code Review Agent
**Purpose**: Code quality review
**Command**: `code-review <file>`
**Keyboard**: `Ctrl+Shift+Alt+R`
**Focus**: Clean code, best practices, SOLID

### üêõ Debug Agent
**Purpose**: Bug analysis
**Command**: `debug-issue <file>`
**Keyboard**: `Ctrl+Shift+Alt+B`
**Focus**: Root cause analysis, fixes

### üèóÔ∏è Architecture Agent
**Purpose**: System design
**Command**: `design-architecture '<prompt>'`
**Focus**: Scalability, patterns, tech stack

### üîß Refactoring Agent
**Purpose**: Code improvement
**Command**: `refactor-code <file>`
**Keyboard**: `Ctrl+Shift+Alt+F`
**Focus**: Code smells, refactoring patterns

## Workflows

### Single Agent
```powershell
# PowerShell terminal
security-review .\auth.js
generate-tests .\service.js
```

### Agent Pipeline
```powershell
# Run all agents in sequence
agent-pipeline .\module.js

# Or in VS Code: Ctrl+Shift+Alt+A
```

### Compare Agents
```powershell
# Get multiple perspectives
compare-agents "best way to handle errors?"
compare-agents "caching strategy?" -Agents architecture,performance
```

### VS Code Tasks
1. `Ctrl+Shift+P`
2. Type "Tasks: Run Task"
3. Select agent task

## Code Snippets

Type in VS Code and press Tab:
- `aisec` ‚Üí Security review marker
- `aitest` ‚Üí Testing marker
- `aidoc` ‚Üí Documentation marker
- `aiperf` ‚Üí Performance marker
- `aireview` ‚Üí Code review marker
- `aidebug` ‚Üí Debug marker
- `airefactor` ‚Üí Refactoring marker
- `aitodo` ‚Üí AI TODO with agent selection
- `aipipe` ‚Üí Full pipeline marker

## Best Practices

### When to Use Which Agent

**Security Agent**: 
- Authentication/authorization code
- User input handling
- API endpoints
- Before production deployment

**Testing Agent**:
- After implementing features
- When test coverage is low
- Before refactoring

**Documentation Agent**:
- Public APIs
- Complex logic
- After major changes

**Performance Agent**:
- Slow features
- Database-heavy code
- Before scaling

**Code Review Agent**:
- Before merging PRs
- Legacy code assessment
- Learning best practices

**Debug Agent**:
- Unexpected errors
- Complex bugs
- Production issues

**Architecture Agent**:
- New projects
- Major features
- Scaling decisions

**Refactoring Agent**:
- Legacy code modernization
- Code smell identification
- Before adding features to messy code

## Keyboard Shortcuts

| Shortcut | Agent |
|----------|-------|
| `Ctrl+Shift+Alt+S` | Security Review |
| `Ctrl+Shift+Alt+T` | Generate Tests |
| `Ctrl+Shift+Alt+D` | Generate Docs |
| `Ctrl+Shift+Alt+P` | Performance Analysis |
| `Ctrl+Shift+Alt+R` | Code Review |
| `Ctrl+Shift+Alt+B` | Debug Issue |
| `Ctrl+Shift+Alt+F` | Refactor Code |
| `Ctrl+Shift+Alt+A` | Full Pipeline |

## Quick Terminal Shortcuts
```powershell
sa file.js    # security-review
ta file.js    # generate-tests
da file.js    # generate-docs
pa file.js    # analyze-performance
ra file.js    # code-review
ap file.js    # agent-pipeline
ca "prompt"   # compare-agents
```

## Logs

All agent interactions are logged to:
```
%USERPROFILE%\.claude-agents\logs\agent-interactions.log
```

## Customization

Agent prompts are in:
```
%USERPROFILE%\.claude-agents\agents\
```

You can edit these files to customize agent behavior!

## Troubleshooting

**Agents not working?**
1. Check `claude-code` is in PATH: `Get-Command claude-code`
2. Reload PowerShell profile: `. $PROFILE`
3. Reload VS Code: `Ctrl+Shift+P` ‚Üí "Developer: Reload Window"

**Module not loading?**
```powershell
Import-Module ClaudeAgents -Force
```

**Need help?**
```powershell
agent-help
Get-Help Invoke-SecurityAgent -Detailed
```

## Examples

### Example 1: Feature Development
```powershell
# 1. Write code with Copilot
# 2. Security review
security-review .\feature.js

# 3. Generate tests
generate-tests .\feature.js

# 4. Add documentation
generate-docs .\feature.js
```

### Example 2: Bug Fix
```powershell
# 1. Analyze bug
debug-issue .\buggy.js -ErrorMessage "TypeError..."

# 2. Review fix
code-review .\buggy.js

# 3. Add regression test
generate-tests .\buggy.js
```

### Example 3: Legacy Code Improvement
```powershell
# 1. Full pipeline
agent-pipeline .\legacy.js

# 2. Focus on refactoring
refactor-code .\legacy.js

# 3. Verify improvements
code-review .\legacy.js
```

## Advanced Usage

### Custom Agent Workflows
```powershell
# Create your own workflow script
function my-workflow {
    param([string]$file)
    
    Write-Host "üöÄ Custom Workflow Starting..."
    
    # Your custom sequence
    security-review $file
    code-review $file
    refactor-code $file
    generate-tests $file
    
    Write-Host "‚úÖ Workflow Complete!"
}
```

### Batch Processing
```powershell
# Run security review on all JS files
Get-ChildItem -Filter *.js -Recurse | ForEach-Object {
    security-review $_.FullName
}
```

## Tips

1. **Start with agent-pipeline** for comprehensive analysis
2. **Use compare-agents** when unsure about approach
3. **Review agent prompts** to understand what they check
4. **Customize prompts** for your project's standards
5. **Log everything** - useful for learning
6. **Combine with Copilot** for maximum productivity

## Integration with Other Tools

### With Git
```powershell
# Pre-commit hook idea
git diff --name-only | ForEach-Object {
    security-review $_
}
```

### With npm scripts
```json
{
  "scripts": {
    "ai-review": "powershell -Command agent-pipeline src/index.js"
  }
}
```

---

**Happy coding with your AI agent team! ü§ñ**

Installation Instructions
Please provide these step-by-step installation instructions:
Step 1: Create Directory Structure
powershell# Create agent directories
New-Item -ItemType Directory -Path "$env:USERPROFILE\.claude-agents\agents" -Force
New-Item -ItemType Directory -Path "$env:USERPROFILE\.claude-agents\config" -Force
New-Item -ItemType Directory -Path "$env:USERPROFILE\.claude-agents\logs" -Force

# Create PowerShell module directory
New-Item -ItemType Directory -Path "$HOME\Documents\PowerShell\Modules\ClaudeAgents\Functions" -Force
Step 2: Create All Agent Prompt Files
[Copilot will create each .txt file with the prompts above]
Step 3: Create PowerShell Module Files
[Copilot will create the .psm1, .psd1, and all function files]
Step 4: Update VS Code Configuration
[Copilot will provide the JSON to merge into existing tasks.json and keybindings.json]
Step 5: Create Snippets
[Copilot will create the snippets file]
Step 6: Update PowerShell Profile
[Copilot will provide the code to add to Microsoft.VSCode_profile.ps1]
Step 7: Create Documentation
[Copilot will create the CLAUDE-AGENTS-GUIDE.md file]
Step 8: Test Installation
powershell# Reload PowerShell profile
. $PROFILE

# Test agent help
agent-help

# Test a simple agent
security-review --help

# Reload VS Code
# Ctrl+Shift+P ‚Üí "Developer: Reload Window"

# Test keyboard shortcut
# Open any file ‚Üí Ctrl+Shift+Alt+S

Expected Output
After installation:

‚úÖ All 8 agent prompt files created
‚úÖ PowerShell module with 11 functions
‚úÖ VS Code tasks for all agents
‚úÖ Keyboard shortcuts configured
‚úÖ Code snippets available
‚úÖ PowerShell profile updated
‚úÖ Documentation created
‚úÖ Log directory ready


Please create all files in order, explaining what each does. Make sure everything is production-ready and follows Windows 11 and PowerShell 7+ best practices.